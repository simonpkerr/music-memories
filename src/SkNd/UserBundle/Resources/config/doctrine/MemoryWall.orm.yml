SkNd\UserBundle\Entity\MemoryWall:
  type: entity
  repositoryClass: SkNd\UserBundle\Repository\MemoryWallRepository
  table: null
  fields:
    id:
      type: integer
      id: true
      generator:
        strategy: AUTO
    name:
      type: string
      length: 50
      default: My Memory Wall
    slug:
      type: string
      length: 255
      gedmo:
        slug:
          fields:
            - name
    description:
      type: string
      length: 255
      nullable: true
    dateCreated:
      type: datetime
      gedmo:
        timestampable:
          on: create
    isPublic:
      type: boolean
      nullable: true
      default: true
    lastUpdated:
      type: datetime
      gedmo:
        timestampable:
          on: update
  lifecycleCallbacks: {  }
  oneToOne:
    associatedDecade:
      targetEntity: SkNd\MediaBundle\Entity\Decade
  oneToMany:
    memoryWallMediaResource:
      targetEntity: MemoryWallMediaResource
      mappedBy: memoryWall
      cascade: ["persist", "remove"]
      orphanRemoval: true
      orderBy:
        dateCreated: desc
  manyToOne:
    user:
      targetEntity: User
      inversedBy: memoryWalls
      #the below statement ensures that from the databases point of view, when users are deleted, the referenced memory walls are also removed
      joinColumn:
        name: user_id
        referencedColumnName: id
        #onDelete: set null
#  manyToMany:
#    mediaResources:
#      targetEntity: SkNd\MediaBundle\Entity\MediaResource
#      orderBy:
#        dateCreated: desc
#      inversedBy: memoryWalls
#      #cascade: ["persist"]
#      joinTable:
#        name: memoryWalls_mediaResources
#        joinColumns:
#          memoryWall_id:
#            referencedColumnName: id
#            #onDelete: set null
#        inverseJoinColumns:
#          mediaResource_id:
#            referencedColumnName: id
#            #onDelete: set null
     
